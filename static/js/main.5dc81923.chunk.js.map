{"version":3,"sources":["assets/images/building1.jpg","assets/images/building2.jpg","assets/images/building3.jpg","assets/images/road.jpg","assets/icons/info.png","assets/icons/github-logo.png","Helpers/helper.js","Algorithms/Queue.js","Algorithms/Stack.js","Algorithms/PriorityQueue.js","Algorithms/algorithms.jsx","Algorithms/MazeAlgorithm.jsx","Tutorial/content.js","Tutorial/Tutorial.jsx","Tesseract/tesseract.jsx","Mappings/cubeToFaceMapper.jsx","Mappings/edgesmapper.jsx","Visualization/visualization.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","setFaceColor","geometry","color","faceIndex","faces","colorsNeedUpdate","elementsNeedUpdate","coordsToIndex","coords","start_index","x","y","z","Math","floor","cubeDims","index","abs","pow","parseInt","checkHowManyFaces","cubeIndex","faceIndexAndCubeIndexToVertex","vertices","v","Queue","this","data","rear","size","element","isEmpty","shift","i","console","log","length","Stack","items","push","pop","str","QElement","priority","PriorityQueue","qElement","contain","splice","isIncluded","String","Graph","props","noOfVertices","AdjList","Map","delay","heuristic","bind","printPath","biBFS","isIntersecting","bidirectional_bfs","set","w","hasEdgeW","hasEdgeV","k","get","get_keys","keys","get_values","startingNode","target","visited","visitedNodesInOrder","distances","Array","fill","pred","q","enqueue","path","getQueueElement","dequeue","get_List","neigh","s","peek","weight","pq","value","front","d","gScore","fScore","hScore","openSet","closedSet","includes","tempGScore","vertex","currentVertex","helper","a","b","source","s_queue","t_queue","s_visited","t_visited","s_parent","t_parent","intersectNode","queue","parent","current","getFront","reverse_path","reverse","concat","newPath","React","Component","Maze","cubes","createMaze","createWalls","obstacles","loader","THREE","texture","load","require","material1","map","material2","material3","random","name","isAWall","offsetX","offsetY","geoX","geoY","normal","offsetZ","geoZ","material","pos","position","rand","obstacle","castShadow","receiveShadow","setY","vertexIndex","content","Modal","show","disableNext","className","id","title","message","Button","disabled","onClick","e","onPrevious","onNext","onClose","Tesseract","animate","createEndingPoint","createStartingPoint","removeEndingPoint","removeStartingPoint","toggle","changeText","onDocumentMouseMove","onDocumentMouseDown","onWindowResize","createGraph","clearWalls","createObstacle","removeObstacle","clearPath","animateVisitedNodes","animateShortestpath","getVertices","setAlgorithm","setDelay","openTutorial","closeTutorial","nextTutorial","state","text","scene","camera","window","innerWidth","innerHeight","renderer","antialias","setSize","setClearColor","mount","appendChild","domElement","background","fog","stats","Stats","dom","style","top","bottom","left","OBSTACLE","START","END","INTERSECTED","isEdit","startOrEnd","hoverStartColor","hoverEndColor","hoverUseColor","light","add","edges","mazeColor","side","vertexColors","cubeNum","edgesMaterial","texture1","texture2","texture3","cubePositions","STARTING_POINT","ENDING_POINT","initialStartCoord","initialEndCoord","initialSFaceIndex","initialEFaceIndex","edge","cube","controls","OrbitControls","minDistance","update","document","addEventListener","mouse","vector","ray","sub","normalize","algo","setState","requestAnimationFrame","render","event","preventDefault","clientX","clientY","setFromCamera","intersects","intersectObjects","children","intersectIndex","object","type","face","removeEventListener","rPos","currentColor","aspect","updateProjectionMatrix","uuid","getObjectByProperty","dispose","remove","maps","faceCoords","mapper","cubeToFaceMapper","noOfFaces","Object","graph","key","addVertex","wallNodes","edgesMapping","facesDirections","0","2","4","6","8","10","neighbours","cornerOrEdgeNeighbours","j","undefined","right","addEdge","values","bfs","dfs","dijkastra","a_star","isArray","alert","nodes","setTimeout","traverse","node","evt","$","algorithms","speed","addClass","tutorialIndex","removeClass","variant","DropdownButton","display","onSelect","Dropdown","Item","eventKey","ref","previousTutorial","src","width","href","alt","Visualizer","ts","App","Boolean","location","hostname","match","ReactDOM","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.5dc81923.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/building1.e0724aec.jpg\";","module.exports = __webpack_public_path__ + \"static/media/building2.9ce44c23.jpg\";","module.exports = __webpack_public_path__ + \"static/media/building3.74480c90.jpg\";","module.exports = __webpack_public_path__ + \"static/media/road.8ae1404e.jpg\";","module.exports = __webpack_public_path__ + \"static/media/info.7547aa78.png\";","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RERCMUIwQTM4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RERCMUIwQTI4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTMyOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJBNDE0QUJDOTlBMTExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8kSqyAAADD5JREFUeNrsXQ2Q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\"","\n\nexport function setFaceColor(geometry, color, faceIndex){\n    //console.log(\"setting face color for index\", faceIndex);\n    geometry.faces[faceIndex].color = color;\n    if(faceIndex%2 === 0){\n        geometry.faces[faceIndex+1].color = color;\n    }\n    else{\n        geometry.faces[faceIndex-1].color = color;\n    }\n    geometry.colorsNeedUpdate = true;\n    geometry.elementsNeedUpdate = true;\n}\n\nexport function coordsToIndex(coords){\n    let x = coords.x;\n    let y = coords.y;\n    let z = coords.z;\n    var start_index;\n    var cubeDims = 9;\n    start_index = {x:Math.floor(cubeDims / 2),y:-Math.floor(cubeDims / 2),z:Math.floor(cubeDims / 2)};\n    let index = Math.abs(x - start_index.x) + cubeDims*Math.abs(y - start_index.y) + Math.pow(cubeDims,2)*Math.abs(z - start_index.z);\n    //console.log(\"index>>>>\", index, this.cubeDims);\n    return parseInt(index)\n}\n\nexport function checkHowManyFaces(x,y,z,cubeIndex){\n    let faces = 0;\n    if(x===cubeIndex || x===-cubeIndex){\n        faces += 1;\n    }\n    if(y===cubeIndex || y === -cubeIndex){\n        faces += 1;\n    }\n    if(z===cubeIndex || z === -cubeIndex){\n        faces += 1;\n    }\n    return faces;\n}\n\nexport function faceIndexAndCubeIndexToVertex(faceIndex, cubeIndex, vertices){\n    // console.log(faceIndex, cubeIndex, vertices)\n    for(let v in vertices){\n        if(vertices[v][3] === cubeIndex){\n            if(vertices[v][4] === faceIndex)\n                return v;\n            if(faceIndex % 2 == 0){\n                if(vertices[v][4] === faceIndex+1)\n                    return v;\n            }\n            else{\n                if(vertices[v][4] === faceIndex-1)\n                    return v;\n            }\n        }\n    }\n    return -1;\n}\n","export default class Queue {\n   \n    constructor(){\n      \n      this.data = [];\n      this.rear = 0;\n      this.size = 200;\n    }\n    \n\n    enqueue(element) {\n     if(this.rear < this.size ) {\n           this.data[this.rear] = element;\n           this.rear = this.rear + 1;\n      }\n    }\n\n\n    length() {\n        \n        return this.rear;\n    }\n\n\n    isEmpty() {\n        \n        return this.rear === 0;\n    }\n\n\n    getFront() {\n        \n        if(this.isEmpty() === false) {\n            return this.data[0];\n        }\n    }\n\n\n    getLast() {\n        \n        if(this.isEmpty() === false) {    \n            return this.data[ this.rear - 1 ] ;\n        }\n    }\n\n\n    dequeue() {\n        \n        if(this.isEmpty() === false) {\n            this.rear = this.rear-1;\n            return this.data.shift();\n        }\n    }\n\n\n    print() { \n        for(let i =0; i < this.rear; i++) {\n            console.log(this.data[i]);\n        }\n    }\n\n\n    clear() {\n        this.data.length = 0;\n        this.rear = 0;\n    }\n }","export default class Stack {\n    constructor() \n    { \n        this.items = []; \n    } \n\n    push(element) \n    { \n        this.items.push(element); \n    } \n\n    pop() \n    {\n        if (this.items.length === 0) \n            return \"Underflow\"; \n        return this.items.pop(); \n    } \n\n    peek() \n    {\n        return this.items[this.items.length - 1]; \n    } \n\n    isEmpty() \n    { \n        return this.items.length === 0; \n    } \n\n    printStack() \n    { \n        var str = \"\"; \n        for (var i = 0; i < this.items.length; i++) \n            str += this.items[i] + \" \"; \n        return str; \n    }\n}\n","class QElement { \n    constructor(priority, element) \n    { \n        this.priority = priority; \n        this.element = element; \n    } \n} \n\nexport default class PriorityQueue {\n    constructor() \n    { \n        this.items = []; \n    } \n\n    enqueue(priority, element) \n    { \n        var qElement = new QElement(priority, element); \n        var contain = false; \n    \n        for (var i = 0; i < this.items.length; i++) { \n            // console.log(\"loop elemtn:::\",this.items[i].element, this.items[i].priority)\n            // console.log(\"enqueue elemtn:::\",qElement.element, qElement.priority)\n            if (this.items[i].priority >= qElement.priority) { \n                this.items.splice(i, 0, qElement); \n                contain = true; \n                break; \n            } \n        } \n    \n        if (!contain) { \n            this.items.push(qElement); \n        } \n    }\n\n    \n    dequeue() \n    { \n        if (this.isEmpty()) \n            return \"Underflow\"; \n        return this.items.shift(); \n    } \n\n\n    front() \n    { \n        if (this.isEmpty()) \n            return \"No elements in Queue\"; \n        return this.items[0]; \n    } \n\n    rear() \n    { \n        if (this.isEmpty()) \n            return \"No elements in Queue\"; \n        return this.items[this.items.length - 1]; \n    } \n\n    isEmpty() \n    { \n        return this.items.length === 0; \n    } \n\n    printPQueue() \n    { \n        var str = \"\"; \n        for (var i = 0; i < this.items.length; i++) \n            str += this.items[i].element + \" \"; \n        return str; \n    } \n\n    includes(element){\n        var isIncluded = false;\n        for (var i = 0; i < this.items.length; i++) \n            if(String(this.items[i].element) === String(element)) isIncluded = true;\n        return isIncluded; \n    }\n} ","import React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Queue from \"./Queue\"\nimport Stack from \"./Stack\"\nimport PriorityQueue from \"./PriorityQueue\"\nimport * as helper from \"../Helpers/helper.js\"\n\n\n\nexport default class Graph extends React.Component  {\n    \n        constructor(props)\n        { \n            super(props);\n            // console.log(\"Creating graph\");\n            // console.log(props);\n            this.noOfVertices = props.length; \n            this.AdjList = new Map(); \n            this.delay = 50;\n            this.heuristic = this.heuristic.bind(this);\n            this.vertices = props.vertices;\n            this.cubeIndex = props.cubeIndex;\n            this.printPath = this.printPath.bind(this);\n            this.biBFS = this.biBFS.bind(this);\n            this.isIntersecting = this.isIntersecting.bind(this);\n            this.bidirectional_bfs = this.bidirectional_bfs.bind(this);\n        }  \n      \n      \n        addVertex(v) { \n            this.AdjList.set(v, []); \n        }\n\n        addEdge(v, w) { \n            //console.log(v,w);\n            let hasEdgeW, hasEdgeV = false;\n            for (let k in this.AdjList.get(String(v))) {\n                if (this.AdjList.get(String(v))[k] === String(w)) {\n                    hasEdgeW = true;\n                }\n            }\n            for (let k in this.AdjList.get(String(w))) {\n                if (this.AdjList.get(String(w))[k] === String(v)) {\n                    hasEdgeV = true;\n                }\n            }\n            if(!hasEdgeW)\n            this.AdjList.get(String(v)).push(String(w)); \n            if(!hasEdgeV)\n            this.AdjList.get(String(w)).push(String(v)); \n        } \n\n        printGraph(){ \n            var get_keys = this.AdjList.keys(); \n        \n            for (var i of get_keys){ \n                var get_values = this.AdjList.get(i); \n                var conc = \"\"; \n        \n                for (var j of get_values) \n                    conc += j + \" \"; \n        \n                // console.log(i + \" -> \" + conc); \n                } \n        }\n      \n        bfs(startingNode, target){\n            var visited = []; \n            const INF = 1000000;\n            let visitedNodesInOrder = [];\n            var distances = Array(this.noOfVertices).fill(INF);\n            // console.log(startingNode, target);\n            distances[startingNode] = 0;\n            var pred = []; \n             for (var i = 0; i < this.noOfVertices; i++)\n             { \n                 visited[i] = false;\n                 pred[i] = -1; \n             }\n        \n            \n            visited[startingNode] = true; \n            var q = new Queue(); \n            q.enqueue(startingNode); \n            var path = [];\n            //path.push(target);\n            while (!q.isEmpty()) { \n                var getQueueElement = q.dequeue(); \n                //  console.log(getQueueElement); \n                var get_List = this.AdjList.get(String(getQueueElement)); \n                //  console.log(\"Getlist\", get_List, q, this.AdjList,  this.AdjList.get(String(getQueueElement)));\n                for (var i in get_List) {\n                        // console.log(\"i...\",i,get_List);\n                        var neigh = get_List[i]; \n                        if (!visited[neigh]) { \n                            visited[neigh] = true; \n                            visitedNodesInOrder.push(neigh);\n                            if (distances[neigh] === INF) {\n                                distances[neigh] = distances[getQueueElement] + 1;\n                                pred[neigh] = getQueueElement;\n                                q.enqueue(neigh);\n                                //console.log(neigh,vertices[neigh] );\n                                if(parseInt(neigh) === parseInt(target)){\n                                    // console.log(pred);\n                                    \n                                    while (pred[target] !== -1) {\n\n                                        path.push(pred[target]); \n                                        target = pred[target]; \n                                    }\n                                    \n                                    //console.log(path);\n                                    // console.log(visitedNodesInOrder);\n                                    return [visitedNodesInOrder, path];\n                                }\n                            } \n                            } \n                    } \n                }\n                return visitedNodesInOrder\n\n        }\n\n        dfs(startingNode, target) {\n            var visited = []; \n            const INF = 1000000;\n            let visitedNodesInOrder = [];\n            var distances = Array(this.noOfVertices).fill(INF);\n            // console.log(startingNode, target);\n            distances[startingNode] = 0;\n            var pred = []; \n             for (var i = 0; i < this.noOfVertices; i++)\n             { \n                 visited[i] = false;\n                 pred[i] = -1; \n             }\n            visited[startingNode] = true; \n            var s = new Stack(); \n            s.push(startingNode); \n            var path = [];\n            while(!s.isEmpty()){\n                let v = s.peek();\n                s.pop();\n                var get_List = this.AdjList.get(String(v)); \n                for(var i in get_List){\n                    var neigh = get_List[i]; \n                        if (!visited[neigh]) { \n                            visited[neigh] = true; \n                            visitedNodesInOrder.push(neigh);\n                            if (distances[neigh] === INF) {\n                                distances[neigh] = distances[v] + 1;\n                                pred[neigh] = v;\n                                s.push(neigh);\n                                //console.log(neigh,vertices[neigh] );\n                                if(parseInt(neigh) === parseInt(target)){\n                                    // console.log(pred);\n                                    \n                                    while (pred[target] !== -1) {\n\n                                        path.push(pred[target]); \n                                        target = pred[target]; \n                                    }\n                                    \n                                   // console.log(path);\n                                    // console.log(visitedNodesInOrder);\n                                    return [visitedNodesInOrder, path];\n                                }\n                            } \n                        }\n            }\n        }\n        return visitedNodesInOrder\n    }\n\n\n    dijkastra(startingNode, target){\n        var weight = [];\n        const INF = 1000000;\n        let visitedNodesInOrder = [];\n        var distances = Array(this.noOfVertices).fill(INF);\n        // console.log(startingNode, target);\n        distances[startingNode] = 0;\n        var pred = []; \n        for (var i = 0; i < this.noOfVertices; i++)\n        { \n            weight[i] = 1;\n            pred[i] = -1; \n        }\n        var pq = new PriorityQueue(); \n        pq.enqueue(distances[startingNode], startingNode); \n        var path = [];\n        while(!pq.isEmpty()){\n            let value = pq.front();\n            // console.log(value);\n            pq.dequeue();\n            var d = value.priority;\n            var v = value.element;\n            if(d > distances[v]) continue\n            var get_List = this.AdjList.get(String(v)); \n            // console.log(get_List);\n            for(var i in get_List){\n                var neigh = get_List[i];\n                var w = weight[neigh];\n                // console.log(neigh, w); \n                // console.log(distances[v] + w < distances[neigh]);\n                if(distances[v] + w < distances[neigh]){\n                    distances[neigh] = distances[v] + w;\n                    pq.enqueue(distances[neigh], neigh); \n                    visitedNodesInOrder.push(neigh);\n                    pred[neigh] = v;\n                    if(parseInt(neigh) === parseInt(target)){\n                        // console.log(pred);\n                        \n                        while (pred[target] !== -1) {\n                            \n                            path.push(pred[target]); \n                            target = pred[target]; \n                        }\n                        \n                        //console.log(path);\n                        // console.log(visitedNodesInOrder);\n                        return [visitedNodesInOrder, path];\n                    }\n                }  \n            } \n        }    \n        return visitedNodesInOrder\n    }\n\n\n    a_star(startingNode, target){\n        let visitedNodesInOrder = [];\n        const INF = 1000000;\n        // console.log(startingNode, target);\n        var pred = []; \n        var gScore = [];\n        var fScore = [];\n        var hScore = [];\n        for (var i = 0; i < this.noOfVertices; i++)\n        { \n            pred[i] = -1; \n            gScore[i] = INF;\n            hScore[i] = INF;\n            fScore[i] = INF;\n        }\n        gScore[startingNode] = 0;\n        hScore[startingNode] = this.heuristic(this.vertices[String(startingNode)], this.vertices[String(target)]);\n        fScore = hScore;\n        let openSet = new PriorityQueue();\n        let closedSet = [];\n        openSet.enqueue(fScore[startingNode], startingNode); \n        var path = [];\n        let parent = [];\n        // console.log(openSet.isEmpty())\n        while(!openSet.isEmpty()){\n            let value = openSet.front();\n            // console.log(openSet, value);\n            if(String(value.element) === String(target)){\n                // console.log(\"Done\");\n                while (pred[target] !== -1) {\n                            \n                    path.push(pred[target]); \n                    target = pred[target]; \n                }\n                \n                // console.log(path);\n                // console.log(visitedNodesInOrder);\n                return [visitedNodesInOrder, path];\n            }\n            openSet.dequeue();\n            var d = value.priority;\n            var v = value.element;\n            closedSet.push(String(v));\n            var get_List = this.AdjList.get(String(v)); \n            // console.log(get_List);\n            for(var i in get_List){\n                var neigh = get_List[i];\n                // console.log(neigh); \n                if(!closedSet.includes(neigh)){\n                    let tempGScore = gScore[v] + this.heuristic(this.vertices[String(neigh)], this.vertices[String(v)]);\n                    // console.log(\"gScores:::\", tempGScore, gScore[neigh])\n                    var vertex = this.vertices[String(neigh)]\n                    var currentVertex = this.vertices[String(v)]\n                    if(openSet.includes(neigh)){\n                        if(tempGScore < gScore[neigh]){\n                            // console.log(\"if here\",closedSet, neigh)\n                            pred[neigh] = v;\n                            var facePenalty = helper.checkHowManyFaces(vertex[0],vertex[1],vertex[2], this.cubeIndex);\n                            // console.log(\"Face\",facePenalty);\n                            gScore[neigh] = tempGScore;\n                            hScore[neigh] = this.heuristic(this.vertices[String(neigh)], this.vertices[String(target)]);\n                            fScore[neigh] = gScore[neigh] + hScore[neigh];\n                            // if(facePenalty-1) fScore[neigh] = fScore[neigh] + 1;\n                            if(String(neigh) === String(target)){\n                                // console.log(\"Done in for loop\", pred);\n                                while (pred[target] !== -1) {\n                                            \n                                    path.push(pred[target]); \n                                    target = pred[target]; \n                                    // console.log(path);\n                                }\n                                \n                                // console.log(path);\n                                // console.log(visitedNodesInOrder);\n                                return [visitedNodesInOrder, path];\n                            }\n                            }\n                        }\n                        else{\n                            // console.log(\"else here\",closedSet, neigh)\n                            pred[neigh] = v;\n                            gScore[neigh] = tempGScore;\n                            var facePenalty = helper.checkHowManyFaces(vertex[0],vertex[1],vertex[2], this.cubeIndex);\n                            // console.log(\"else Face\",facePenalty);\n                            hScore[neigh] = this.heuristic(this.vertices[String(neigh)], this.vertices[String(target)]);\n                            fScore[neigh] = gScore[neigh] + hScore[neigh];\n                            // if(facePenalty-1) fScore[neigh] = fScore[neigh] + 1;\n                            // try adding penalty only if current face and neigh lie on same co ordinates\n                            // console.log(currentVertex, vertex, currentVertex[0] === vertex[0] && currentVertex[1] === vertex[1] && currentVertex[2] === vertex[2])\n                            if(currentVertex[0] === vertex[0] && currentVertex[1] === vertex[1] && currentVertex[2] === vertex[2]) \n                            fScore[neigh] = fScore[neigh] + 1;\n                            if(String(neigh) === String(target)){\n                                // console.log(\"Done in for loop\", pred);\n                                while (pred[target] !== -1) {\n                                            \n                                    path.push(pred[target]); \n                                    target = pred[target]; \n                                    // console.log(path);\n                                }\n                                \n                                // console.log(path);\n                                // console.log(visitedNodesInOrder);\n                                return [visitedNodesInOrder, path];\n                            }\n                            visitedNodesInOrder.push(neigh);\n                            openSet.enqueue(fScore[neigh], neigh);\n                        }   \n            }\n            // console.log(\"fScores:::\",fScore[neigh]) \n        } \n        // console.log(\"openset after loop:::\", openSet.printPQueue())\n    } \n        // console.log(visitedNodesInOrder, closedSet)  \n        return visitedNodesInOrder\n    }\n\n    heuristic(a,b){\n        //console.log(\"heuristic\", a,b, this.AdjList);\n        // var heuristic = Math.sqrt(Math.pow((a[0] - b[0]),2) + \n        //                           Math.pow((a[1] - b[1]),2) +\n        //                           Math.pow((a[2] - b[2]),2))\n\n        var heuristic = Math.abs((a[0] - b[0]))+ \n                        Math.abs((a[1] - b[1]))+\n                        Math.abs((a[2] - b[2]))\n        // console.log(\"heuristic:::\", heuristic)                        \n        return heuristic;\n    }\n\n\n    // Bidirectional BFS\n\n\n    bidirectional_bfs(source, target){\n        let s_visited = [];\n        let t_visited = [];\n        let s_parent = [];\n        let t_parent = [];\n        let visitedNodesInOrder = [];\n        this.visitedNodesInOrder = visitedNodesInOrder;\n        let s_queue = new Queue();\n        let t_queue = new Queue();\n        this.s_queue = s_queue;\n        this.t_queue = t_queue;\n        this.s_visited = s_visited;\n        this.t_visited = t_visited;\n        this.s_parent = s_parent;\n        this.t_parent = t_parent;\n        let intersectNode = -1;\n        // console.log(this.s_visited);\n        for(var i = 0; i<this.noOfVertices; i++){\n            this.s_visited.push(false); \n            this.t_visited.push(false); \n        }\n        // console.log(this.s_visited);\n        this.s_queue.enqueue(source); \n        this.s_visited[source] = true; \n        this.s_parent[source]=-1; \n    \n        this.t_queue.enqueue(target); \n        this.t_visited[target] = true; \n        this.t_parent[target] = -1; \n\n        while (!this.s_queue.isEmpty() && !this.t_queue.isEmpty()){\n            // console.log(\"Queues....\", this.s_queue, this.t_queue)\n            this.biBFS(this.s_queue, this.s_visited, this.s_parent);\n            this.biBFS(this.t_queue, this.t_visited, this.t_parent);\n\n            intersectNode = this.isIntersecting(this.s_visited, this.t_visited); \n\n            if(intersectNode !== -1) \n            { \n                let path = this.printPath(this.s_parent, this.t_parent, source, target, intersectNode); \n                return [visitedNodesInOrder, path]\n            } \n        }\n        return -1;\n    }\n\n\n    biBFS(queue, visited, parent){\n        let current = queue.getFront();\n        queue.dequeue();\n        var get_List = this.AdjList.get(String(current)); \n        for(var i in get_List){\n            var neigh = get_List[i];\n            // console.log(neigh); \n            if(!visited[neigh]){\n                this.visitedNodesInOrder.push(neigh);\n                parent[neigh] = current;\n                visited[neigh] = true;\n                queue.enqueue(neigh);\n            }\n        }\n\n    }\n\n\n    printPath(s_parent, t_parent, source, target, intersectNode){\n        let path = [];\n        path.push(intersectNode);\n\n        let i = intersectNode;\n        while(s_parent[i]!==source){\n            path.push(s_parent[i]);\n            i=s_parent[i];\n        }\n\n        i = intersectNode;\n        let reverse_path = []\n        while(t_parent[i]!==target){\n            reverse_path.push(t_parent[i]);\n            i=t_parent[i];\n        }\n\n        reverse_path = reverse_path.reverse();\n        path = path.concat(reverse_path);\n        for(i = 0; i < path.length; i++){\n            // console.log(path[i]);\n        }\n\n        let newPath = [];\n        for(i = 0; i < path.length/2; i++){\n                newPath.push(path[i])\n                if(newPath.length <= path.length)\n                newPath.push(path[path.length-i-1])\n        }\n        newPath.push(target);\n\n\n        for(i = 0; i < path.length; i++){\n            // console.log(\"newpath...\", newPath[i]);\n        }\n        \n        return newPath;\n    }\n\n\n    isIntersecting(s_visited, t_visited){\n        for(var i=0;i<this.noOfVertices;i++){ \n            if(s_visited[i] && t_visited[i]) \n                return i; \n        } \n        return -1; \n    }\n\n}\n","import React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as setFaceColor from \"../Helpers/helper.js\"\nimport Stack from \"./Stack\"\nimport * as helper from \"../Helpers/helper.js\"\nimport * as THREE from \"three\";\n\n\n\nexport default class Maze extends React.Component  {\n    \n        constructor(props)\n        { \n            super(props);\n            // console.log(\"Creating Maze\");\n            // console.log(props);\n            this.noOfVertices = props.length; \n            this.vertices = props.vertices;\n            this.cubeIndex = props.cubeIndex;\n            this.cubes = props.cubes;\n            // this.neighbours = props.neighbours;\n            this.createMaze = this.createMaze.bind(this);\n            this.createWalls = this.createWalls.bind(this);\n            this.obstacles = [];\n            const loader = new THREE.TextureLoader(new THREE.LoadingManager());\n            let texture = loader.load(\n                require(\"../assets/images/building1.jpg\")\n                );\n            \n            this.material1 = new THREE.MeshBasicMaterial({\n                 map: texture\n            });\n\n            texture = loader.load(\n                require(\"../assets/images/building2.jpg\")\n                );\n            \n            this.material2 = new THREE.MeshBasicMaterial({\n                 map: texture\n            });\n\n            texture = loader.load(\n                require(\"../assets/images/building3.jpg\")\n                );\n            \n            this.material3 = new THREE.MeshBasicMaterial({\n                 map: texture\n            });\n        \n        }\n        \n        createMaze(){\n\n            for(var i =0; i< this.noOfVertices; i++){\n                let rand = Math.random()\n                // console.log(rand);\n                 if(rand<0.25){\n                    this.createWalls(this.vertices[i]);\n                 }\n            }\n            return this.obstacles;\n        }\n\n        createWalls(vertex){\n            let x = vertex[0];\n            let y = vertex[1];\n            let z = vertex[2];\n            let index = vertex[3];\n            let faceIndex = vertex[4];\n            // console.log(this.cubes[index].geometry.faces[faceIndex].name);\n            let name = this.cubes[index].geometry.faces[faceIndex].name;\n            if(name === \"start\" || name === \"end\" || this.cubes[index].geometry.faces[faceIndex].isAWall) return\n            let normal = this.cubes[index].geometry.faces[faceIndex].normal;\n            // console.log(\"normal\", normal);\n            let offsetX, offsetY, offsetZ = 0;\n            let geoX, geoY, geoZ = 0;\n            if(normal.x === 1){\n                offsetX = 1;\n                offsetY = 0;\n                offsetZ = 0;\n                geoX = Math.floor(Math.random() * 3) + 1;\n                geoY = 0.95;\n                geoZ = 0.95;\n            }\n            else if (normal.y === 1){\n                offsetX = 0;\n                offsetY = 1;\n                offsetZ = 0;\n                geoY = Math.floor(Math.random() * 3) + 1;\n                geoX = 0.95;\n                geoZ = 0.95;\n            }\n            else if (normal.z === 1){\n                offsetX = 0;\n                offsetY = 0;\n                offsetZ = 1;\n                geoZ = Math.floor(Math.random() * 3) + 1;\n                geoX = 0.95;\n                geoY = 0.95;\n            }\n            else if(normal.x === -1){\n                offsetX = -1;\n                offsetY = 0;\n                offsetZ = 0;\n                geoX = Math.floor(Math.random() * 3) + 1;\n                geoY= 0.95; \n                geoZ = 0.95;\n            }\n            else if (normal.y === -1){\n                offsetX = 0;\n                offsetY = -1;\n                offsetZ = 0;\n                geoY = Math.floor(Math.random() * 3) + 1;\n                geoX = 0.95;\n                geoZ = 0.95;\n            }\n            else if (normal.z === -1){\n                offsetX = 0;\n                offsetY = 0;\n                offsetZ = -1;\n                geoZ = Math.floor(Math.random() * 3) + 1;\n                geoX= 0.95; \n                geoY = 0.95;\n            }\n\n\n            // console.log(\"creating obstacle\");\n            let pos = this.cubes[index].position;\n            // console.log(pos, x, y, z);\n            let geometry = new THREE.BoxGeometry(geoX,geoY,geoZ);\n            \n            // });\n            // const material = new THREE.MeshPhongMaterial({\n            //     color: 0x00f00f,\n            //     vertexColors: THREE.FaceColors \n            // });\n            let rand = Math.random();\n            let material;\n            if(rand < 0.33){\n               material = this.material1;\n            }\n            else if(rand > 0.66){\n                material = this.material2;\n            }\n            else{\n                material = this.material3;\n            }\n            let obstacle = new THREE.Mesh(geometry, material);\n            obstacle.position.set(pos.x + offsetX, pos.y + offsetY, pos.z + offsetZ);\n            obstacle.name = \"obstacle\";\n            // obstacle.vertex = this.vertices[];\n            // groupCubes.add(cubes[cubeNum]);\n            obstacle.castShadow = true;\n            obstacle.receiveShadow = true;\n            // this.scene.add(obstacle); \n            obstacle.position.setY = 25;\n            // new TWEEN.Tween(obstacle.position)\n            //                 .to({ y: 10}, 2000)\n            //                 .easing(TWEEN.Easing.Bounce.Out)\n            //                 .start();\n            this.cubes[index].geometry.faces[faceIndex].isAWall = true;\n            let vertexIndex = helper.faceIndexAndCubeIndexToVertex(faceIndex, helper.coordsToIndex(new THREE.Vector3(pos.x,pos.y,pos.z)), this.vertices);\n            obstacle.vertexIndex = vertexIndex;\n            this.obstacles.push(obstacle);\n            if(faceIndex%2===0){\n                this.cubes[index].geometry.faces[faceIndex+1].isAWall = true;\n            }\n            else{\n                this.cubes[index].geometry.faces[faceIndex-1].isAWall = true;\n            }\n        }\n      \n      \n\n\n}\n","let content = {\n    \"title1\": \"Tutorial\",\n    \"message1\": \"Welcome to the 3D Pathfinding Visualizer.\",\n\n    \"title2\": \"Change Start/End points\",\n    \"message2\": \"First, start by changing the Start/End points. To do that, click \\\"Change Start/End points\\\" button, \\\n                and then click on the Start/End point (Red/Green) and hover over the cube and choose your new spot.  You can click outside and rotate the cube. Then you can click on any point to \\\n                to make it your Start/End point\",\n\n    \"title3\": \"Create Walls\",\n    \"message3\": \"You can create walls just by clicking on any node around the cube.\",\n\n    \"title4\": \"Choose Algorithm\",\n    \"message4\": \"You can choose any Algorithm you want to visualize. Just select your choice from the dropdown\",\n\n    \"title5\": \"Choose Speed\",\n    \"message5\": \"You can choose the speed at which you want to algorithm to be visualized.\",\n\n    \"title6\": \"Create Maze\",\n    \"message6\": \"You can create a Random Maze around the cube by clicking \\\"Create Maze\\\" button.\",\n\n    \"title7\": \"Clear Wall\",\n    \"message7\": \"You can clear the walls that you have created or that were created from maze creation by clicking \\\"Clear Wall\\\" button.\",\n\n    \"title8\": \"Clear path\",\n    \"message8\": \"You can clear the nodes and path visualized by clicking \\\"Clear path\\\" button.\",\n\n    \"title9\": \"Enjoy!\",\n    \"message9\": \"Now have fun, go for it. You have earned it\"\n\n\n}\n\nexport default content","import React from \"react\";\nimport Button from 'react-bootstrap/Button';\nimport './Tutorial.css';\nimport * as $ from 'jquery';\n\n\nexport default class Modal extends React.Component {\n\n    render() {\n        // console.log(this.props);\n        if(!this.props.show){\n            // $(\".canvas-container\").removeClass(\"blur-filter\"); \n            return null;\n        }\n        \n        // console.log(this.props.index);\n        let disableNext = false;\n        if(this.props.index===8) disableNext = true;\n        return (\n        <div className=\"tutorial\" id=\"modal\">\n            <h2>{this.props.title}</h2>\n            <div className=\"content\">{this.props.message}</div>\n            <div className=\"actions\">\n                <Button className=\"previous-button\" disabled={!this.props.index} onClick={e => { this.props.onPrevious(e); }} >\n                    Previous\n                </Button>\n                <Button className=\"next-button\" disabled={disableNext} onClick={e => { this.props.onNext(e); }} >\n                    Next\n                </Button>\n                <Button className=\"close-button\" onClick={e => { this.props.onClose(e);  }} >\n                    Close\n                </Button>\n            </div>\n        </div>);\n    }\n}","import React, {Component, useState } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport * as OrbitControls from \"three-orbitcontrols\";\nimport * as TWEEN from \"tween\";\nimport * as helper from \"../Helpers/helper.js\"\nimport cubesToFaces from \"../Mappings/cubeToFaceMapping.js\";\nimport edgesMapping from \"../Mappings/edgesMapping\";\nimport mapper from \"../Mappings/edgesmapper\";\nimport Graph from \"../Algorithms/algorithms\";\nimport cubeToFaceMapper from \"../Mappings/cubeToFaceMapper\";\nimport Maze from \"../Algorithms/MazeAlgorithm\";\nimport * as $ from 'jquery';\nimport content from \"../Tutorial/content\"\nimport Stats from \"three/examples/jsm/libs/stats.module.js\";\n\nimport Tutorial from \"../Tutorial/Tutorial\"\nimport Button from 'react-bootstrap/Button';\nimport DropdownButton from 'react-bootstrap/DropdownButton';\nimport Dropdown from 'react-bootstrap/Dropdown';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './tesseract.css';\n\n\nexport default class Tesseract extends React.Component {\n    constructor(props) {\n        super(props);\n        this.animate = this.animate.bind(this);\n        this.createEndingPoint = this.createEndingPoint.bind(this);\n        this.createStartingPoint = this.createStartingPoint.bind(this);\n        this.removeEndingPoint = this.removeEndingPoint.bind(this);\n        this.removeStartingPoint = this.removeStartingPoint.bind(this);\n        this.coordsToIndex = this.coordsToIndex.bind(this);\n        this.toggle = this.toggle.bind(this);\n        this.changeText = this.changeText.bind(this);\n        this.onDocumentMouseMove = this.onDocumentMouseMove.bind(this);\n        this.onDocumentMouseDown = this.onDocumentMouseDown.bind(this);\n        this.onWindowResize = this.onWindowResize.bind(this);\n        this.createGraph = this.createGraph.bind(this);\n        this.clearWalls = this.clearWalls.bind(this);\n        this.createObstacle = this.createObstacle.bind(this);\n        this.removeObstacle = this.removeObstacle.bind(this);\n        this.clearPath = this.clearPath.bind(this);\n        this.animateVisitedNodes = this.animateVisitedNodes.bind(this);\n        this.animateShortestpath = this.animateShortestpath.bind(this);\n        this.getVertices = this.getVertices.bind(this);\n        this.faceIndexAndCubeIndexToVertex = this.faceIndexAndCubeIndexToVertex.bind(this);\n        this.setAlgorithm = this.setAlgorithm.bind(this);\n        this.setDelay = this.setDelay.bind(this);\n        this.openTutorial = this.openTutorial.bind(this);\n        this.closeTutorial = this.closeTutorial.bind(this);\n        this.nextTutorial = this.nextTutorial.bind(this);\n        this.state = { text: \"Change Start/End points\",\n                        show: -1};\n    }\n    \n    \n    componentDidMount(){\n\n        let scene = new THREE.Scene();\n        let camera = new THREE.PerspectiveCamera( \n            75, \n            window.innerWidth / window.innerHeight, \n            0.1, \n            1000);\n\n        const config = {antialias: true}\n        let renderer = new THREE.WebGLRenderer(config);\n        this.renderer = renderer;\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.setClearColor( 0x545454, 1 );\n        this.mount.appendChild( this.renderer.domElement );\n        this.scene = scene;\n        this.scene.background = new THREE.Color(0x121212);\n        this.scene.fog = new THREE.Fog(0xffffff, 0, 150);\n        this.stats = new Stats();\n        this.stats.dom.style.top = \"auto\";\n        this.stats.dom.style.bottom = '5px';\n        this.stats.dom.style.left = '3px';\n        this.mount.appendChild(this.stats.dom);\n\n        var OBSTACLE = \"obstacle\";\n        this.OBSTACLE = OBSTACLE;\n        var START = \"start\";\n        this.START = START;\n        var END = \"end\";\n        this.END = END;\n\n        var INTERSECTED;\n        this.INTERSECTED = INTERSECTED;\n\n        var isEdit;\n        this.isEdit = isEdit;\n\n        var startOrEnd;\n        this.startOrEnd = startOrEnd;\n\n        var hoverStartColor;\n        this.hoverStartColor = hoverStartColor;\n\n        var hoverEndColor;\n        this.hoverEndColor = hoverEndColor;\n\n        var hoverUseColor;\n        this.hoverUseColor = hoverUseColor;\n\n\n        var light = new THREE.AmbientLight( {color:0x111111});\n        scene.add( light );\n\n        const groupCubes = new THREE.Group();\n        const cubes = {};\n        this.cubes = cubes;\n        const edges = {};\n        this.edges = edges;\n       \n        this.delay = 200;\n        var mazeColor = new THREE.Color(0xffffff);\n        this.mazeColor = mazeColor;\n\n        let cubeDims = 9\n        this.cubeDims = cubeDims;\n        const loader = new THREE.TextureLoader(new THREE.LoadingManager());\n        let texture = loader.load(\n            require(\"../assets/images/road.jpg\"));\n        let material;\n        \n            material = new THREE.MeshLambertMaterial({\n            map: texture,\n            side: THREE.FrontSide,\n            vertexColors: THREE.FaceColors,\n        });\n        for(let cubeNum = 0; cubeNum < Math.pow(cubeDims, 3); cubeNum++){\n            let geometry = new THREE.BoxGeometry(1,1,1);\n            // const material = new THREE.MeshLambertMaterial({\n                //     vertexColors: THREE.FaceColors,\n            //     });\n            this.cubes[cubeNum] = new THREE.Mesh(geometry, material);\n            this.cubes[cubeNum].name = String(cubeNum);\n            //console.log(this.cubes[cubeNum]);\n           \n            \n            for(var i =0;i<12;i++){\n                this.cubes[cubeNum].geometry.faces[i].color = mazeColor;\n                this.cubes[cubeNum].geometry.faces[i].isAWall = false;\n            }\n            this.cubes[cubeNum].geometry.elementsNeedUpdate = true;\n\n            \n            const edges = new THREE.EdgesGeometry(geometry);\n\n            const edgesMaterial = new THREE.LineBasicMaterial({\n                color: 0x000000\n            });\n            this.edges[cubeNum] = new THREE.LineSegments(edges, edgesMaterial);\n            \n            // groupCubes.add(cubes[cubeNum]);\n            this.scene.add(this.cubes[cubeNum])\n            this.scene.add(this.edges[cubeNum])\n        }\n\n        this.texture1 = loader.load(\n            require(\"../assets/images/building1.jpg\"));\n    \n        this.texture2 = loader.load(\n            require(\"../assets/images/building2.jpg\"));\n    \n        this.texture3 = loader.load(\n            require(\"../assets/images/building3.jpg\"));\n\n        let start_index = new THREE.Vector3();\n        this.start_index = start_index\n        this.start_index = {x:Math.floor(cubeDims / 2),y:-Math.floor(cubeDims / 2),z:Math.floor(cubeDims / 2)};\n        // console.log(\"satrindex\", this.start_index);\n        let cubeIndex = parseInt(cubeDims / 2)\n        this.cubeIndex = cubeIndex;\n        // console.log(\"cubeindex>:::\", this.cubeIndex);\n        let cubePositions = [];\n        this.cubePositions = cubePositions;\n        let STARTING_POINT = 0\n        let ENDING_POINT = 3\n        this.STARTING_POINT = STARTING_POINT\n        this.ENDING_POINT = ENDING_POINT\n        let initialStartCoord;\n        this.initialStartCoord = initialStartCoord;\n        var initialEndCoord;\n        this.initialEndCoord = initialEndCoord;\n        var initialSFaceIndex = 8;\n        this.initialSFaceIndex = initialSFaceIndex;\n        var initialEFaceIndex = 8;\n        this.initialEFaceIndex = initialEFaceIndex;\n        for (let z = this.cubeIndex; z >= -this.cubeIndex; z--) {\n            for (let y = -this.cubeIndex; y <= this.cubeIndex; y ++) {\n                for (let x = this.cubeIndex; x >= -this.cubeIndex; x --) {\n                    this.cubePositions.push([x, y, z]);\n                    if((this.coordsToIndex(new THREE.Vector3(x,y,z))) === this.ENDING_POINT)\n                    {\n                        this.createEndingPoint(x,y,z,this.initialEFaceIndex);\n                    }\n                    if((this.coordsToIndex(new THREE.Vector3(x,y,z))) === this.STARTING_POINT)\n                    {\n                        this.createStartingPoint(x,y,z,this.initialSFaceIndex);\n                    }\n                }\n            }\n        }\n        \n        for(let edge in edges){\n            this.edges[edge].position.set(...this.cubePositions[edge])\n        }\n        for(let cube in cubes){\n            this.cubes[cube].position.set(...this.cubePositions[cube])\n        }\n           \n        // scene.add(groupCubes);\n        var controls = new OrbitControls( camera, renderer.domElement );\n        \n        this.controls = controls;\n        this.controls.minDistance = 8;\n        this.camera = camera;\n        this.camera.position.z = 8;\n        this.camera.position.y = 8;\n        this.camera.position.x = 8;\n        this.controls.update();\n        document.addEventListener( 'mousedown', this.onDocumentMouseDown, false );\n        document.addEventListener( 'touchstart', this.onDocumentMouseDown, false );\n        window.addEventListener(\"resize\", this.onWindowResize, false);\n        var mouse = new THREE.Vector2();\n        this.mouse = mouse;\n        //this.animate = animate;\n        this.animate();\n        var vector = new THREE.Vector3( this.mouse.x, this.mouse.y, 1 );\n        var ray = new THREE.Raycaster( this.camera.position, vector.sub( this.camera.position ).normalize() );\n        this.ray = ray;\n        this.getVertices();\n        this.source = 1;\n        this.target = 7; \n        this.algo = 0;\n    }\n\n        \n    changeText(){\n    // console.log(this.state.text, String(this.state.text) === \"Change Start/End points\");\n    if(String(this.state.text) === \"Change Start/End points\"){\n        var text =  \"Exit Edit Mode\";\n        this.setState({ text: text },\n        ()=>{\n            // console.log(this.state.text);\n        }); \n\n    }\n    else{\n        this.setState({ text:\"Change Start/End points\" });\n        // document.removeEventListener( 'mousemove', this.onDocumentMouseMove, false );\n\n    }  \n    this.toggle(); \n    } \n\n\n    animate() {\n        //console.log(\"this...\", this);\n        requestAnimationFrame( this.animate );\n        \n        this.renderer.render( this.scene, this.camera );\n        this.controls.update();\n        this.stats.update();\n    }\n    \n    \n    coordsToIndex(coords){\n        let x = coords.x;\n        let y = coords.y;\n        let z = coords.z;\n        let index = Math.abs(x - this.start_index.x) + this.cubeDims*Math.abs(y - this.start_index.y) + Math.pow(this.cubeDims,2)*Math.abs(z - this.start_index.z);\n        //console.log(\"index>>>>\", index, this.cubeDims);\n        return index\n    }\n\n    \n    onDocumentMouseDown( event ) \n    {\n        event.preventDefault();   \n        this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n        this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n        \n        this.ray.setFromCamera( this.mouse, this.camera );\n        var intersects = this.ray.intersectObjects( this.scene.children, true );\n        this.intersects = intersects;\n        //console.log(this.intersects);\n        if(this.intersects.length > 0){\n            // console.log(this.intersects[0]);\n            var intersectIndex = -1;\n            for(var i=0;i<this.intersects.length;i++){\n                if(this.intersects[i].object.type === \"Mesh\"){\n                    intersectIndex = i;\n                    break;\n                }\n            }\n            if(intersectIndex === -1) return\n            //console.log(this.intersects[intersectIndex]);\n            // console.log(this.intersects[intersectIndex]);\n            // console.log(\"vertex\",this.intersects[intersectIndex].face.vertex);\n            //console.log(\"name:::\", this.intersects[intersectIndex].face.name);\n            // intersects[0].object.material.color.setHex(Math.random() * 0xffffff);\n            let faceIndex = this.intersects[intersectIndex].faceIndex;\n            let position = new THREE.Vector3();\n            position = this.intersects[intersectIndex].object.position;\n            let ind = this.coordsToIndex(position);\n            //console.log(\"ind...\", ind);\n            let normal = new THREE.Vector3();\n            normal = this.intersects[intersectIndex].face.normal;\n\n            let offsetX, offsetY, offsetZ = 0;\n            let geoX, geoY, geoZ = 0;\n            \n            if( this.intersects[intersectIndex].face.name === this.START || this.intersects[intersectIndex].face.name === this.END){\n                // console.log(\"worked\");\n                if(this.isEdit){\n                    document.addEventListener( 'mousemove', this.onDocumentMouseMove, false );\n                    if(this.intersects[intersectIndex].face.name === this.START){\n                        this.startOrEnd = 1;\n                        this.hoverStartColor = new THREE.Color(0xe84735);\n                        this.hoverUseColor = this.hoverStartColor;\n                    }\n                    else if(this.intersects[intersectIndex].face.name === this.END){\n                        this.startOrEnd = 0;\n                        this.hoverEndColor = new THREE.Color(0x74d486);\n                        this.hoverUseColor = this.hoverEndColor;\n                    }\n                }\n                else{\n                    document.removeEventListener( 'mousemove', this.onDocumentMouseMove, false );\n\n                }\n            }\n            else if(this.isEdit){\n                var index = this.intersects[intersectIndex].faceIndex;\n                // console.log(\"changing to::::\", intersects[intersectIndex]);\n                if(this.intersects[intersectIndex].object.name !== this.OBSTACLE){\n                    if(this.startOrEnd === 1 && this.intersects[intersectIndex].object.geometry.faces[index].name !== this.END){\n                        var rPos = this.cubes[this.coordsToIndex(this.initialStartCoord)].position;\n                        this.removeStartingPoint(rPos.x, rPos.y, rPos.z, this.initialSFaceIndex);\n                        this.initialSFaceIndex = index;\n                        var pos = this.intersects[intersectIndex].object.position;\n                        this.STARTING_POINT = this.coordsToIndex(new THREE.Vector3(pos.x, pos.y, pos.z))\n                        this.createStartingPoint(pos.x, pos.y, pos.z, this.initialSFaceIndex);\n                    }\n                    else if(this.startOrEnd === 0 && this.intersects[intersectIndex].object.geometry.faces[index].name !== this.START){\n                        var rPos = this.cubes[this.coordsToIndex(this.initialEndCoord)].position;\n                        this.removeEndingPoint(rPos.x, rPos.y, rPos.z, this.initialEFaceIndex);\n                        this.initialEFaceIndex = index\n                        var pos = this.intersects[intersectIndex].object.position;\n                        this.ENDING_POINT = this.coordsToIndex(new THREE.Vector3(pos.x, pos.y, pos.z))\n                        this.createEndingPoint(pos.x, pos.y, pos.z, this.initialEFaceIndex);\n                    }\n                }\n                document.removeEventListener( 'mousemove', this.onDocumentMouseMove, false );\n            }\n            else if(this.intersects[intersectIndex].object.name !== \"obstacle\"){\n                if(normal.x === 1){\n                    offsetX = 1;\n                    offsetY = 0;\n                    offsetZ = 0;\n                    geoX = Math.floor(Math.random() * 3) + 1;\n                    geoY = 0.95;\n                    geoZ = 0.95;\n                }\n                else if (normal.y === 1){\n                    offsetX = 0;\n                    offsetY = 1;\n                    offsetZ = 0;\n                    geoY = Math.floor(Math.random() * 3) + 1;\n                    geoX = 0.95;\n                    geoZ = 0.95;\n                }\n                else if (normal.z === 1){\n                    offsetX = 0;\n                    offsetY = 0;\n                    offsetZ = 1;\n                    geoZ = Math.floor(Math.random() * 3) + 1;\n                    geoX = 0.95;\n                    geoY = 0.95;\n                }\n                else if(normal.x === -1){\n                    offsetX = -1;\n                    offsetY = 0;\n                    offsetZ = 0;\n                    geoX = Math.floor(Math.random() * 3) + 1;\n                    geoY= 0.95; \n                    geoZ = 0.95;\n                }\n                else if (normal.y === -1){\n                    offsetX = 0;\n                    offsetY = -1;\n                    offsetZ = 0;\n                    geoY = Math.floor(Math.random() * 3) + 1;\n                    geoX = 0.95;\n                    geoZ = 0.95;\n                }\n                else if (normal.z === -1){\n                    offsetX = 0;\n                    offsetY = 0;\n                    offsetZ = -1;\n                    geoZ = Math.floor(Math.random() * 3) + 1;\n                    geoX= 0.95; \n                    geoY = 0.95;\n                }\n                    this.createObstacle(geoX,geoY,geoZ,offsetX,offsetY,offsetZ,intersectIndex,faceIndex);\n            }        \n            else{\n                this.removeObstacle(intersectIndex);\n            }\n        }\n    }\n\n\n    onDocumentMouseMove(event){\n        this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n        this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n        this.ray.setFromCamera( this.mouse, this.camera );\n        this.intersects = this.ray.intersectObjects( this.scene.children, true );\n        this.intersects = this.ray.intersectObjects(this.scene.children);\n        if(this.intersects.length > 0){\n            var intersectIndex = -1;\n            for(var i=0;i<this.intersects.length;i++){\n                if(this.intersects[i].object.type === \"Mesh\"){\n                    intersectIndex = i;\n                    break;\n                }\n            }\n            if(intersectIndex === -1) return\n            if (this.intersects[intersectIndex] !== this.INTERSECTED )//|| this.intersects[0].face ) \n\t\t    {\n                if (this.INTERSECTED) {\n                    // console.log(\"removing from inside\",this.INTERSECTED.face.name);\n                    if( (this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex)].name !== this.START && this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex)].name !== this.END)\n                         && this.INTERSECTED.object.name !== this.OBSTACLE){\n                        this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex)].color = this.INTERSECTED.currentColor;\n                        if(this.faceIndex % 2 === 0){\n                            this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex+1)].color = this.INTERSECTED.currentColor;\n                        }\n                        else{\n                            this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex-1)].color = this.INTERSECTED.currentColor;\n                        }\n                        this.INTERSECTED.object.geometry.colorsNeedUpdate = true;\n                        this.INTERSECTED.object.geometry.elementsNeedUpdate = true;\n                    }\n                }\n                \n                \n                this.INTERSECTED = this.intersects[intersectIndex];\n                let faceIndex = this.INTERSECTED.faceIndex;  \n                this.faceIndex = faceIndex;\n                this.INTERSECTED.currentColor = this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex)].color;\n                // console.log(\"intersect\", this.INTERSECTED);\n                // console.log(\"hover\", this.intersects[intersectIndex].object.geometry.faces[parseInt(this.faceIndex)].name);\n                if(this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex)].name !== this.START && this.INTERSECTED.object.geometry.faces[parseInt(faceIndex)].name !== this.END\n                && this.INTERSECTED.object.name !== this.OBSTACLE){\n                    helper.setFaceColor(this.INTERSECTED.object.geometry, this.hoverUseColor, this.faceIndex);\n                }\n            }\n        } \n        else {\n            if (this.INTERSECTED) {\n                // console.log(\"removing from outside\");\n                if( (this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex)].name !== this.START && this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex)].name !== this.END\n                && this.INTERSECTED.object.name !== this.OBSTACLE)){\n                this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex)].color = this.INTERSECTED.currentColor;\n                    if(this.faceIndex%2 === 0){\n                        this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex+1)].color = this.INTERSECTED.currentColor;\n                    }\n                    else{\n                        this.INTERSECTED.object.geometry.faces[parseInt(this.faceIndex-1)].color = this.INTERSECTED.currentColor;\n                    }\n                    this.INTERSECTED.object.geometry.colorsNeedUpdate = true;\n                    this.INTERSECTED.object.geometry.elementsNeedUpdate = true;\n                }\n            }\n            \n            this.INTERSECTED = null;\n            }\n    }\n\n\n    onWindowResize(){\n        this.camera.aspect = window.innerWidth / window.innerHeight;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n    }    \n\n\n    toggle(){\n        // console.log(\"clicked....\");\n        if(this.isEdit === true){\n            // this.controls.enabled = true;\n            this.isEdit = false;\n        }\n        else{\n            // this.controls.enabled = false;\n            this.isEdit = true;\n        }\n    }\n    \n\n    createStartingPoint(x,y,z, faceIndex){\n        // console.log(\"starting poijt is:::\", this.coordsToIndex(new THREE.Vector3(x,y,z)));\n        this.source = this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex].vertex;\n        var color = new THREE.Color( 0xff0000 );\n        this.initialStartCoord = {x,y,z};\n        helper.setFaceColor(this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry, color, faceIndex);\n        this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex].name = this.START;\n        if(faceIndex%2 === 0){\n            this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex+1].name = this.START;\n        }\n        else{\n            this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex-1].name = this.START;\n        }\n    }\n    \n    \n    createEndingPoint(x,y,z, faceIndex){\n        // console.log(\"ending poijt is:::\", this.coordsToIndex(new THREE.Vector3(x,y,z)));\n        this.target = this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex].vertex;\n        this.initialEndCoord = {x,y,z};\n        var color = new THREE.Color( 0x04b31b );\n        helper.setFaceColor(this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry, color, faceIndex);\n        this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex].name = this.END;\n        if(faceIndex%2 === 0){\n            this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex+1].name = this.END;\n        }\n        else{\n            this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex-1].name = this.END;\n        }\n    }\n\n    removeStartingPoint(x,y,z, faceIndex){\n        // console.log(\"removed starting poijt is:::\", this.coordsToIndex(new THREE.Vector3(x,y,z)));\n        helper.setFaceColor(this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry, this.mazeColor, faceIndex);\n        this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex].name = \"\";\n        if(faceIndex%2 === 0){\n            this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex+1].name = \"\";\n        }\n        else{\n            this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex-1].name = \"\";\n        }\n    }\n\n\n    removeEndingPoint(x,y,z, faceIndex){\n        // console.log(\"removed ending poijt is:::\", this.coordsToIndex(new THREE.Vector3(x,y,z)));\n        helper.setFaceColor(this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry, this.mazeColor, faceIndex);\n        this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex].name = \"\";\n        if(faceIndex%2 === 0){\n            this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex+1].name = \"\";\n        }\n        else{\n            this.cubes[this.coordsToIndex(new THREE.Vector3(x,y,z))].geometry.faces[faceIndex-1].name = \"\";\n        }\n    }\n\n\n    createObstacle(geoX,geoY,geoZ,offsetX,offsetY,offsetZ,intersectIndex,faceIndex){\n        // console.log(\"creating obstacle\");\n        let pos = this.intersects[intersectIndex].object.position;\n        let geometry = new THREE.BoxGeometry(geoX,geoY,geoZ);\n        let material;\n        const loader = new THREE.TextureLoader(new THREE.LoadingManager());\n        let rand = Math.random();\n        let texture;\n        if(rand < 0.33){\n            texture = this.texture1;\n        }\n        else if(rand > 0.66){\n            texture = this.texture2; \n        }\n        else{\n            texture = this.texture3;\n        }\n        \n        \n        material = new THREE.MeshBasicMaterial({\n            map: texture\n        });\n        // const material = new THREE.MeshPhongMaterial({\n        //     color: 0x00f00f,\n        //     vertexColors: THREE.FaceColors \n        // });\n        let obstacle = new THREE.Mesh(geometry, material);\n        obstacle.position.set(pos.x + offsetX, pos.y + offsetY, pos.z + offsetZ);\n        obstacle.name = this.OBSTACLE;\n        // obstacle.vertex = this.vertices[];\n        // groupCubes.add(cubes[cubeNum]);\n        // obstacle.castShadow = true;\n        // obstacle.receiveShadow = true;\n        this.scene.add(obstacle); \n        obstacle.position.setY = 25;\n        // new TWEEN.Tween(obstacle.position)\n        //                 .to({ y: 10}, 2000)\n        //                 .easing(TWEEN.Easing.Bounce.Out)\n        //                 .start();\n        this.intersects[intersectIndex].object.geometry.faces[faceIndex].isAWall = true;\n        let vertexIndex = this.faceIndexAndCubeIndexToVertex(faceIndex, this.coordsToIndex(new THREE.Vector3(pos.x,pos.y,pos.z)));\n        obstacle.vertexIndex = vertexIndex;\n        if(faceIndex%2===0){\n            this.intersects[intersectIndex].object.geometry.faces[faceIndex+1].isAWall = true;\n        }\n        else{\n            this.intersects[intersectIndex].object.geometry.faces[faceIndex-1].isAWall = true;\n        }\n    }\n\n\n    removeObstacle(intersectIndex){\n        // console.log(\"remving obstacle\", this.intersects[intersectIndex].object.vertexIndex);\n        let p = this.intersects[intersectIndex].object.position;\n        let vertexIndex = this.intersects[intersectIndex].object.vertexIndex;\n        // console.log(\"vertexIndex...\", vertexIndex);\n        this.cubes[this.vertices[vertexIndex][3]].geometry.faces[this.vertices[vertexIndex][4]].isAWall = false;\n\n        let uuid = this.intersects[intersectIndex].object.uuid;\n        const object = this.scene.getObjectByProperty( 'uuid', uuid );\n        // console.log(object);\n        object.geometry.dispose();\n        object.material.dispose();\n        this.scene.remove( object );\n    }\n\n\n    getVertices(){\n        let vertex = 0;\n        let vertices = {};\n        let maps = cubeToFaceMapper(this.cubeIndex);\n        for (let z = this.cubeIndex; z >= -this.cubeIndex; z--) {\n            for (let y = -this.cubeIndex; y <= this.cubeIndex; y ++) {\n                for (let x = this.cubeIndex; x >= -this.cubeIndex; x --) {\n                    var noOfFaces = helper.checkHowManyFaces(x,y,z, this.cubeIndex);\n                    if(noOfFaces!==0){\n                        var index = this.coordsToIndex(new THREE.Vector3(x,y,z));\n                        // var map = cubesToFaces[index];\n                        var map = maps[index];\n                       // console.log(\"mpa and indx:::\", map, index, this.cubeIndex)\n                        for(var i = 0; i < noOfFaces; i++){\n                            //console.log(map[i]);\n                            //console.log(vertex,x,y,z);\n                            this.cubes[index].geometry.faces[map[i]].vertex = vertex;\n                            this.cubes[index].geometry.faces[map[i]+1].vertex = vertex;\n                            \n                            vertices[vertex] = [x,y,z,index, map[i]];\n                            vertex += 1;\n                        } \n                    }\n                }\n            }\n        }\n        this.vertices = vertices;\n    }\n\n    createGraph(){\n        this.clearPath();\n        var length = Object.keys(this.vertices).length;\n        var graph = new Graph({length: length, vertices: this.vertices, cubeIndex: this.cubeIndex});\n        // console.log(this.vertices);\n        for(let key in this.vertices){\n            graph.addVertex(key);\n        }\n        let wallNodes = [];\n        let edgesMapping = mapper(this.cubes, this.vertices, this.cubeIndex);\n        for(let edge in edgesMapping){\n            let e = edgesMapping[edge];\n            let index = this.vertices[edge][3];\n            if(this.cubes[index].geometry.faces[this.vertices[edge][4]].isAWall === true){\n                wallNodes.push(parseInt(edge));\n            }\n            \n        }\n        // console.log(\"walls\", wallNodes);\n        for(let edge in edgesMapping){\n            let e = edgesMapping[edge];\n            let index = this.vertices[edge][3];\n            if(this.cubes[index].geometry.faces[this.vertices[edge][4]].isAWall === true){\n               continue;\n            }\n            for(let i = 0; i<4; i++){\n                if(!wallNodes.includes(e[i]))\n                {\n                    graph.addEdge(edge, e[i]);\n                }\n            }\n            \n        }\n            \n        // graph.printGraph();\n        if(this.algo === 0){\n            alert(\"Please select an algorithm\");\n            return;\n        }\n        let values;\n        // console.log(\"came here\", this.algo);\n        switch(parseInt(this.algo)){\n            case 0:\n                //  console.log(\"came here\");\n                 values = graph.bfs(this.source, this.target); break;\n            case 1:\n                 values = graph.dfs(this.source, this.target); break;\n            case 2:\n                 values = graph.dijkastra(this.source, this.target); break;\n            case 3:\n                 values = graph.a_star(this.source, this.target); break;\n            case 4:\n                 values = graph.bidirectional_bfs(this.source, this.target); break;\n\n        }\n        // let values = graph.bfs(this.source, this.target);\n        let visitedNodesInOrder = values[0];\n        let path = values[1];\n        if(path === undefined || !Array.isArray(path) || path.length < 2){\n            alert(\"No path exists\");\n            return;\n        }\n        // console.log(\"path is...\", path, path.length);\n        // console.log(\"nodes...\", visitedNodesInOrder);\n        this.animateVisitedNodes(visitedNodesInOrder, path);\n    }\n\n    animateVisitedNodes(nodes, path){\n        for(let i = 0 ; i<= nodes.length-1; i++){\n            if(i === nodes.length-1){\n                setTimeout(()=>{\n                    this.animateShortestpath(path.reverse());\n                },this.delay*i);\n                return;\n            }\n            setTimeout(()=>{\n                let v = nodes[i];\n                helper.setFaceColor(this.cubes[this.coordsToIndex(new THREE.Vector3(this.vertices[v][0], this.vertices[v][1], this.vertices[v][2]))].geometry,\n                         new THREE.Color(0x88ebe5), this.vertices[v][4]);\n            },this.delay*i);\n        } \n    }\n\n    animateShortestpath(nodes){\n        for(let i = 1 ; i< nodes.length; i++){\n            setTimeout(()=>{\n                let v = nodes[i];\n                helper.setFaceColor(this.cubes[this.coordsToIndex(new THREE.Vector3(this.vertices[v][0], this.vertices[v][1], this.vertices[v][2]))].geometry,\n                         new THREE.Color(0x7532a8), this.vertices[v][4]);\n            },this.delay*i);\n        }\n    }\n\n\n    faceIndexAndCubeIndexToVertex(faceIndex, cubeIndex){\n        for(let v in this.vertices){\n            if(this.vertices[v][3] === cubeIndex){\n                if(this.vertices[v][4] === faceIndex)\n                    return v;\n                if(faceIndex % 2 == 0){\n                    if(this.vertices[v][4] === faceIndex+1)\n                        return v;\n                }\n                else{\n                    if(this.vertices[v][4] === faceIndex-1)\n                        return v;\n                }\n            }\n        }\n        return -1;\n    }\n\n\n    clearWalls(){\n        for(let v in this.vertices){\n            this.cubes[this.vertices[v][3]].geometry.faces[this.vertices[v][4]].isAWall = false;\n        }\n        let obstacles = []\n        this.scene.traverse((node) => {\n            if(node instanceof THREE.Mesh){\n                if(node.name === this.OBSTACLE){\n                    obstacles.push(node);\n                }\n            }\n        });\n        for(var i =0; i < obstacles.length; i++){\n            let uuid = obstacles[i].uuid;\n            const object = this.scene.getObjectByProperty( 'uuid', uuid );\n            object.geometry.dispose();\n            object.material.dispose();\n            this.scene.remove( object );\n        }\n    }\n\n    \n    clearPath(){\n        for(let v in this.vertices){\n            helper.setFaceColor(this.cubes[this.vertices[v][3]].geometry, this.mazeColor, this.vertices[v][4]);\n        }\n        for (let z = this.cubeIndex; z >= -this.cubeIndex; z--) {\n            for (let y = -this.cubeIndex; y <= this.cubeIndex; y ++) {\n                for (let x = this.cubeIndex; x >= -this.cubeIndex; x --) {\n                    this.cubePositions.push([x, y, z]);\n                    if((this.coordsToIndex(new THREE.Vector3(x,y,z))) === this.ENDING_POINT)\n                    {\n                        this.createEndingPoint(x,y,z,this.initialEFaceIndex);\n                    }\n                    if((this.coordsToIndex(new THREE.Vector3(x,y,z))) === this.STARTING_POINT)\n                    {\n                        this.createStartingPoint(x,y,z,this.initialSFaceIndex);\n                    }\n                }\n            }\n        }\n    }\n\n    setAlgorithm(evt, name){\n        this.algo = evt; \n        // console.log(this.algo,name);\n        $(\"#dropdown-algorithms\").text(this.algorithms[this.algo]); \n    }\n\n    setDelay(delay, name){\n        switch(parseInt(delay)){\n            case 1:\n                this.delay = 1000;\n                break;\n            case 2:\n                this.delay = 500;\n                break;\n            case 3:\n                this.delay = 100;\n                break;\n            case 4:\n                this.delay = 20\n                break;\n            case 5:\n                this.delay = 1;\n                break;\n        }\n        // console.log(this.delay);\n        $(\"#dropdown-speed\").text(this.speed[delay]);\n    }\n\n    createMaze(){\n        var length = Object.keys(this.vertices).length;\n        let maze = new Maze({\n            length: length, \n            vertices: this.vertices, \n            cubeIndex: this.cubeIndex,\n            cubes: this.cubes,\n        });\n        // console.log(\"befire\", this.cubes[0]);\n        let obstacles = maze.createMaze();\n        // console.log(obstacles, this.cubes[3]);\n        for(let obstacle in obstacles){\n            this.scene.add(obstacles[obstacle])\n        }\n    }\n\n\n    openTutorial(){\n        // let i = this.state.show.find(true);\n        // if(i === undefined) i = 0;\n        $(\".canvas-container\").addClass(\"blur-filter\");\n        document.removeEventListener( 'mousedown', this.onDocumentMouseDown, false );\n        document.removeEventListener( 'mousemove', this.onDocumentMouseMove, false );\n        this.tutorialIndex = 0;\n        // console.log(\"enteres modeal\",this.tutorialIndex);\n        this.setState({\n            show: this.tutorialIndex\n          });\n    }\n\n    \n    closeTutorial(){\n        document.addEventListener( 'mousedown', this.onDocumentMouseDown, false );\n        document.addEventListener( 'mousemove', this.onDocumentMouseMove, false );\n        $(\".canvas-container\").removeClass(\"blur-filter\");\n        this.tutorialIndex = -1;\n        // console.log(\"clsoing modeal\",this.tutorialIndex);\n        this.setState({\n            show: this.tutorialIndex\n          });\n    }\n\n\n    nextTutorial(){\n        this.tutorialIndex++;\n        // console.log(\"next modeal\",this.tutorialIndex);\n        this.setState({\n            show: this.tutorialIndex\n          });\n    }\n\n\n    previousTutorial(){\n        this.tutorialIndex--;\n        // console.log(\"next modeal\",this.tutorialIndex);\n        this.setState({\n            show: this.tutorialIndex\n          });\n    }\n\n    render() {\n        const { text } = this.state;\n        this.algorithms = [\"Breadth First Search\",\"Depth First Search\",\n                           \"Dijkastra\",\"A* Search\",\"Bidirectional BFS\"];\n        this.speed = [\"Very Slow\",\"Slow\",\"Normal\",\"Fast\",\"Superfast\"];\n    //    console.log(content, this.state.show)\n        return (\n            <div>\n            <div className=\"canvas-container\">\n                <div className=\"container\" >\n                    <span className=\"title\">3D Pathfinding Visualizer</span>\n                    <Button id=\"edit\" variant=\"primary\" onClick={this.changeText}>{text}</Button>\n                    <DropdownButton id=\"dropdown-algorithms\" title=\"Choose Algorithm\" style={{\n                        display: \"inline\"\n                    }} onSelect={(evt, name) => {this.setAlgorithm(evt, name)}}>\n                        <Dropdown.Item eventKey=\"0\" >{this.algorithms[0]}</Dropdown.Item>\n                        <Dropdown.Item eventKey=\"1\" >{this.algorithms[1]}</Dropdown.Item>\n                        <Dropdown.Item eventKey=\"2\">{this.algorithms[2]}</Dropdown.Item>\n                        <Dropdown.Item eventKey=\"3\">{this.algorithms[3]}</Dropdown.Item>\n                        <Dropdown.Item eventKey=\"4\">{this.algorithms[4]}</Dropdown.Item>\n                    </DropdownButton>\n                    <DropdownButton id=\"dropdown-speed\" title=\"Choose Speed\" style={{\n                        display: \"inline\"\n                    }} onSelect={(evt, name) => { this.setDelay(evt, name)}}>\n                         <Dropdown.Item eventKey=\"0\" >{this.speed[0]}</Dropdown.Item>\n                        <Dropdown.Item eventKey=\"1\" >{this.speed[1]}</Dropdown.Item>\n                        <Dropdown.Item eventKey=\"2\">{this.speed[2]}</Dropdown.Item>\n                        <Dropdown.Item eventKey=\"3\">{this.speed[3]}</Dropdown.Item>\n                        <Dropdown.Item eventKey=\"4\">{this.speed[4]}</Dropdown.Item>\n                    </DropdownButton>\n                    <Button id=\"visualize\" variant=\"success\" onClick={this.createGraph.bind(this)}>Start Visualization</Button>\n                    <Button id=\"maze\" variant=\"primary\" onClick={this.createMaze.bind(this)}>Create Maze</Button>\n                    <Button id=\"clearWalls\" variant=\"danger\" onClick={this.clearWalls}>Clear Walls</Button>\n                    <Button id=\"clearPath\" variant=\"danger\" onClick={this.clearPath}>Clear Path</Button>\n                </div>\n                    <div className=\"canvas\" ref={(mount) => { this.mount = mount }}></div>\n            </div>\n                    <Tutorial message={content[\"message1\"]} title={content[\"title1\"]} index={this.tutorialIndex} show={this.state.show===0} \n                    onClose={this.closeTutorial} onNext={this.nextTutorial.bind(this)}></Tutorial>\n                    <Tutorial message={content[\"message2\"]} title={content[\"title2\"]} index={this.tutorialIndex} show={this.state.show===1} \n                    onClose={this.closeTutorial} onNext={this.nextTutorial.bind(this)} onPrevious={this.previousTutorial.bind(this)}></Tutorial>\n                    <Tutorial message={content[\"message3\"]} title={content[\"title3\"]} index={this.tutorialIndex} show={this.state.show===2} \n                    onClose={this.closeTutorial} onNext={this.nextTutorial.bind(this)} onPrevious={this.previousTutorial.bind(this)}></Tutorial>\n                    <Tutorial message={content[\"message4\"]} title={content[\"title4\"]} index={this.tutorialIndex} show={this.state.show===3} \n                    onClose={this.closeTutorial} onNext={this.nextTutorial.bind(this)} onPrevious={this.previousTutorial.bind(this)}></Tutorial>\n                    <Tutorial message={content[\"message5\"]} title={content[\"title5\"]} index={this.tutorialIndex} show={this.state.show===4} \n                    onClose={this.closeTutorial} onNext={this.nextTutorial.bind(this)} onPrevious={this.previousTutorial.bind(this)}></Tutorial>\n                    <Tutorial message={content[\"message6\"]} title={content[\"title6\"]} index={this.tutorialIndex} show={this.state.show===5} \n                    onClose={this.closeTutorial} onNext={this.nextTutorial.bind(this)} onPrevious={this.previousTutorial.bind(this)}></Tutorial>\n                    <Tutorial message={content[\"message7\"]} title={content[\"title7\"]} index={this.tutorialIndex} show={this.state.show===6} \n                    onClose={this.closeTutorial} onNext={this.nextTutorial.bind(this)} onPrevious={this.previousTutorial.bind(this)}></Tutorial>\n                    <Tutorial message={content[\"message8\"]} title={content[\"title8\"]} index={this.tutorialIndex} show={this.state.show===7} \n                    onClose={this.closeTutorial} onNext={this.nextTutorial.bind(this)} onPrevious={this.previousTutorial.bind(this)}></Tutorial>\n                    <Tutorial message={content[\"message9\"]} title={content[\"title9\"]} index={this.tutorialIndex} show={this.state.show===8} \n                    onClose={this.closeTutorial} onPrevious={this.previousTutorial.bind(this)}></Tutorial>\n                   \n                <div id=\"developer\">\n                    Developed by <strong> Yogesh Kumar</strong>\n                </div>\n                <a id=\"openTutorial\">\n                <img src={require('../assets/icons/info.png')} style={{  width:\"2vw\"}} variant=\"danger\" onClick={this.openTutorial}></img>\n                </a>\n                <a id=\"github\" href=\"https://github.com/b-yogesh/3D-PathFinder\">\n                    <img src={require('../assets/icons/github-logo.png')} alt=\"\" style={{  width:\"2vw\"}}/>\n                </a>\n            </div>\n        ); \n        }\n \n}","import React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as helper from \"../Helpers/helper.js\"\nimport * as THREE from \"three\";\n\n\nexport default function cubeToFaceMapper(cubeIndex){\n\n    // value :: 1 -> x, 2->y, 3 ->z\n    let faceCoords = {\n        \"x\"  : 0 ,\n        \"-x\" : 2 ,\n        \"y\"  : 4 ,\n        \"-y\" : 6,\n        \"z\"  : 8,\n        \"-z\" : 10 \n    }\n\n    let mapper = {};\n    // console.log(\"cubeIndx\", cubeIndex);\n    for (let z = cubeIndex; z >= -cubeIndex; z--) {\n        for (let y = -cubeIndex; y <= cubeIndex; y ++) {\n            for (let x = cubeIndex; x >= -cubeIndex; x --) {\n                let index = helper.coordsToIndex(new THREE.Vector3(x, y ,z))\n                mapper[index] = []\n                if(x === cubeIndex)\n                    mapper[index].push(faceCoords[\"x\"])\n                if(y === cubeIndex)\n                    mapper[index].push(faceCoords[\"y\"])\n                if(z === cubeIndex)\n                    mapper[index].push(faceCoords[\"z\"])\n                if(x === -cubeIndex)\n                    mapper[index].push(faceCoords[\"-x\"])\n                if(y === -cubeIndex)\n                    mapper[index].push(faceCoords[\"-y\"])\n                if(z === -cubeIndex)\n                    mapper[index].push(faceCoords[\"-z\"])\n\n            }\n        }\n    }\n    // console.log(\"mapper:::::\",mapper);\n    return mapper;\n\n}","import React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as helper from \"../Helpers/helper.js\"\nimport * as THREE from \"three\";\n\n\nexport default function mapper(cubes, vertices, cubeIndex){\n\n    // value :: 0 -> x, 1->y, 2 ->z\n    let facesDirections = {\n        0 : [1,2],\n        2 : [1,2],\n        4 : [0,2],\n        6 : [0,2],\n        8 : [0,1],\n        10 : [0,1]\n    }\n\n    // let adjacentFaces = {\n    //     0 : [4,6,8,10],\n    //     2 : [4,6,8,10],\n    //     4 : [0,2,8,10],\n    //     6 : [0,2,8,10],\n    //     8 : [0,2,4,6],\n    //     10 : [0,2,4,6]\n    // }\n\n\n    let neighbours = {}\n    // console.log(cubeIndex);\n    for(let i in vertices){\n        let v = vertices[i];\n        let x = v[0];\n        let y = v[1];\n        let z = v[2];\n        let index = v[3];\n        let faceIndex= parseInt(v[4]);\n        if(!faceIndex%2!==0 && faceIndex !== 0){\n            faceIndex = v[4]-1\n        }\n        let direction = [];\n        direction = facesDirections[faceIndex];\n        // let index = helper.coordsToIndex(new THREE.Vector3(x,y,z));\n\n        let noOfFaces = helper.checkHowManyFaces(x,y,z,cubeIndex);\n\n        // if the current vertex lies on an edge or corner\n        let cornerOrEdgeNeighbours;\n        if(noOfFaces-1){\n            cornerOrEdgeNeighbours = []\n            for(let j = 0; j<6; j++){\n                if(cubes[index].geometry.faces[j*2].vertex !== undefined && j*2 !== faceIndex){\n                    cornerOrEdgeNeighbours.push(cubes[index].geometry.faces[j*2].vertex)\n                }\n            }\n        }\n\n        let left, right, top, bottom;\n\n        if(faceIndex === 0 || faceIndex === 2){\n            if(y !== cubeIndex)\n                right = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                    helper.coordsToIndex(new THREE.Vector3(x, y+1 ,z)),vertices)\n            if(y !== -cubeIndex)\n                left = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                    helper.coordsToIndex(new THREE.Vector3(x, y-1 ,z)),vertices)\n            if(z !== cubeIndex)\n                top = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                    helper.coordsToIndex(new THREE.Vector3(x, y ,z+1)),vertices)\n            if(z !== -cubeIndex)\n                bottom = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                        helper.coordsToIndex(new THREE.Vector3(x, y ,z-1)),vertices)\n        }\n\n        if(faceIndex === 4 || faceIndex === 6){\n            if(x !== cubeIndex)\n                right = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                        helper.coordsToIndex(new THREE.Vector3(x+1, y ,z)),vertices)\n            if(x !== -cubeIndex)\n                left = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                       helper.coordsToIndex(new THREE.Vector3(x-1, y ,z)),vertices)\n            if(z !== cubeIndex)\n                top = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                      helper.coordsToIndex(new THREE.Vector3(x, y ,z+1)),vertices)\n            if(z !== -cubeIndex)\n                bottom = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                        helper.coordsToIndex(new THREE.Vector3(x, y ,z-1)),vertices)\n        }\n\n        if(faceIndex === 8 || faceIndex === 10){\n            if(x !== cubeIndex)\n                right = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                        helper.coordsToIndex(new THREE.Vector3(x+1, y ,z)),vertices)\n            if(x !== -cubeIndex)\n                left = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                       helper.coordsToIndex(new THREE.Vector3(x-1, y ,z)),vertices)\n            if(y !== cubeIndex)\n                top = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                      helper.coordsToIndex(new THREE.Vector3(x, y+1 ,z)),vertices)\n            if(y !== -cubeIndex)\n                bottom = helper.faceIndexAndCubeIndexToVertex(faceIndex, \n                        helper.coordsToIndex(new THREE.Vector3(x, y-1 ,z)),vertices)\n        }   \n\n        neighbours[i] = [];\n        if(cornerOrEdgeNeighbours)\n            for(let k = 0; k<cornerOrEdgeNeighbours.length; k++){\n                neighbours[i].push(parseInt(cornerOrEdgeNeighbours[k])); \n            }\n        if(left)\n            neighbours[i].push(parseInt(left))\n        if(right)\n            neighbours[i].push(parseInt(right))\n        if(top)\n            neighbours[i].push(parseInt(top))\n        if(bottom)\n            neighbours[i].push(parseInt(bottom))\n            \n        }\n        // console.log(neighbours)\n        return neighbours\n}","import React, {Component} from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Tesseract from \"../Tesseract/tesseract\";\n\nexport default class Visualizer extends React.Component {\n    constructor(props){\n        super(props);\n        let ts = new Tesseract();\n        this.ts = ts;\n    }\n\n    componentDidMount() {\n        this.ts = Tesseract.bind(this)\n        //this.ts()\n    }\n\n    render() {\n        return(\n            <div>\n                <Tesseract/>\n            </div>\n        )\n    }\n}\n","import React from 'react';\nimport './App.css';\nimport Visualizer from \"./Visualization/visualization\";\n\nfunction App() {\n\n  return (\n    <div className=\"App\">\n      <Visualizer> </Visualizer>\n    </div>\n  );\n}  \n\nexport default App;\n        ","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}